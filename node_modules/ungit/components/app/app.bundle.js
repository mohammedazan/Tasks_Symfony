(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var storage = require('ungit-storage');
var $ = require('jquery');
components.register('app', function (args) {
    return new AppViewModel(args.appContainer, args.server);
});
var AppViewModel = /** @class */ (function () {
    function AppViewModel(appContainer, server) {
        var _this = this;
        this.appContainer = appContainer;
        this.server = server;
        this.template = 'app';
        if (window.location.search.indexOf('noheader=true') < 0) {
            this.header = components.create('header', { app: this });
        }
        this.modal = ko.observable(null);
        this.repoList = ko.observableArray(this.getRepoList()); // visitedRepositories is legacy, remove in the next version
        this.repoList.subscribe(function (newValue) {
            storage.setItem('repositories', JSON.stringify(newValue));
        });
        this.content = ko.observable(components.create('home', { app: this }));
        this.currentVersion = ko.observable();
        this.latestVersion = ko.observable();
        this.showNewVersionAvailable = ko.observable();
        this.newVersionInstallCommand =
            (ungit.platform == 'win32' ? '' : 'sudo -H ') + 'npm update -g ungit';
        this.bugtrackingEnabled = ko.observable(ungit.config.bugtracking);
        this.bugtrackingNagscreenDismissed = ko.observable(storage.getItem('bugtrackingNagscreenDismissed'));
        this.showBugtrackingNagscreen = ko.computed(function () {
            return !_this.bugtrackingEnabled() && !_this.bugtrackingNagscreenDismissed();
        });
        this.gitVersionErrorDismissed = ko.observable(storage.getItem('gitVersionErrorDismissed'));
        this.gitVersionError = ko.observable();
        this.gitVersionErrorVisible = ko.computed(function () {
            return (!ungit.config.gitVersionCheckOverride &&
                _this.gitVersionError() &&
                !_this.gitVersionErrorDismissed());
        });
    }
    AppViewModel.prototype.getRepoList = function () {
        var localStorageRepo = JSON.parse(storage.getItem('repositories') || storage.getItem('visitedRepositories') || '[]');
        var newRepos = localStorageRepo
            .concat(ungit.config.defaultRepositories || [])
            .filter(function (v, i, a) { return a.indexOf(v) === i; })
            .sort();
        storage.setItem('repositories', JSON.stringify(newRepos));
        return newRepos;
    };
    AppViewModel.prototype.updateNode = function (parentElement) {
        ko.renderTemplate('app', this, {}, parentElement);
    };
    AppViewModel.prototype.shown = function () {
        var _this = this;
        // The ungit.config constiable collections configuration from all different paths and only updates when
        // ungit is restarted
        if (!ungit.config.bugtracking) {
            // Whereas the userconfig only reflects what's in the ~/.ungitrc and updates directly,
            // but is only used for changing around the configuration. We need to check this here
            // since ungit may have crashed without the server crashing since we enabled bugtracking,
            // and we don't want to show the nagscreen twice in that case.
            this.server
                .getPromise('/userconfig')
                .then(function (userConfig) { return _this.bugtrackingEnabled(userConfig.bugtracking); })
                .catch(function (e) { return _this.server.unhandledRejection(e); });
        }
        this.server
            .getPromise('/latestversion')
            .then(function (version) {
            if (!version)
                return;
            _this.currentVersion(version.currentVersion);
            _this.latestVersion(version.latestVersion);
            _this.showNewVersionAvailable(!ungit.config.ungitVersionCheckOverride && version.outdated);
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
        this.server
            .getPromise('/gitversion')
            .then(function (gitversion) {
            if (gitversion && !gitversion.satisfied) {
                _this.gitVersionError(gitversion.error);
            }
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    AppViewModel.prototype.updateAnimationFrame = function (deltaT) {
        if (this.content() && this.content().updateAnimationFrame)
            this.content().updateAnimationFrame(deltaT);
    };
    AppViewModel.prototype.onProgramEvent = function (event) {
        if (event.event === 'request-credentials') {
            this._handleCredentialsRequested(event);
        }
        else if (event.event === 'request-remember-repo') {
            this._handleRequestRememberRepo(event);
        }
        else if (event.event === 'modal-show-dialog') {
            this.showModal(event.modal);
        }
        else if (event.event === 'modal-close-dialog') {
            $('.modal.fade').modal('hide');
            this.modal(undefined);
        }
        if (this.content() && this.content().onProgramEvent) {
            this.content().onProgramEvent(event);
        }
        if (this.header && this.header.onProgramEvent) {
            this.header.onProgramEvent(event);
        }
    };
    AppViewModel.prototype._handleRequestRememberRepo = function (event) {
        var repoPath = event.repoPath;
        if (this.repoList.indexOf(repoPath) != -1)
            return;
        this.repoList.push(repoPath);
    };
    AppViewModel.prototype._handleCredentialsRequested = function (event) {
        // Only show one credentials dialog if we're asked to show another one while the first one is open
        // This happens for instance when we fetch nodes and remote tags at the same time
        if (!this._isShowingCredentialsDialog) {
            this._isShowingCredentialsDialog = true;
            components.showModal('credentialsmodal', { remote: event.remote });
        }
    };
    AppViewModel.prototype.showModal = function (modal) {
        this.modal(modal);
        // when dom is ready, open the modal
        var checkExists = setInterval(function () {
            var modalDom = $('.modal.fade');
            if (modalDom.length) {
                clearInterval(checkExists);
                modalDom.modal();
                modalDom.on('hidden.bs.modal', function () {
                    modal.close();
                });
            }
        }, 200);
    };
    AppViewModel.prototype.gitSetUserConfig = function (bugTracking) {
        var _this = this;
        this.server.getPromise('/userconfig').then(function (userConfig) {
            userConfig.bugtracking = bugTracking;
            return _this.server.postPromise('/userconfig', userConfig).then(function () {
                _this.bugtrackingEnabled(bugTracking);
            });
        });
    };
    AppViewModel.prototype.enableBugtracking = function () {
        this.gitSetUserConfig(true);
    };
    AppViewModel.prototype.dismissBugtrackingNagscreen = function () {
        storage.setItem('bugtrackingNagscreenDismissed', true);
        this.bugtrackingNagscreenDismissed(true);
    };
    AppViewModel.prototype.dismissGitVersionError = function () {
        storage.setItem('gitVersionErrorDismissed', true);
        this.gitVersionErrorDismissed(true);
    };
    AppViewModel.prototype.dismissNewVersion = function () {
        this.showNewVersionAvailable(false);
    };
    AppViewModel.prototype.templateChooser = function (data) {
        if (!data)
            return '';
        return data.template;
    };
    return AppViewModel;
}());

},{"jquery":undefined,"knockout":undefined,"ungit-components":undefined,"ungit-storage":undefined}]},{},[1])
//# sourceMappingURL=app.bundle.js.map
