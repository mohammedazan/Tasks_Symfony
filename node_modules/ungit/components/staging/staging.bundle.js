(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentRoot = void 0;
var ComponentRoot = /** @class */ (function () {
    function ComponentRoot() {
        this.defaultDebounceOption = {
            maxWait: 1500,
            leading: false,
            trailing: true
        };
    }
    ComponentRoot.prototype.isSamePayload = function (value) {
        var jsonString = JSON.stringify(value);
        if (this._apiCache === jsonString) {
            ungit.logger.debug("ignoring redraw for same ".concat(this.constructor.name, " payload."));
            return true;
        }
        ungit.logger.debug("redrawing ".concat(this.constructor.name, " payload.  \n").concat(jsonString));
        this._apiCache = jsonString;
        return false;
    };
    ComponentRoot.prototype.clearApiCache = function () {
        this._apiCache = undefined;
    };
    return ComponentRoot;
}());
exports.ComponentRoot = ComponentRoot;

},{}],2:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ko = require('knockout');
var _ = require('lodash');
var octicons = require('octicons');
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var filesToDisplayIncrmentBy = 50;
var filesToDisplayLimit = filesToDisplayIncrmentBy;
var mergeTool = ungit.config.mergeTool;
var ComponentRoot = require('../ComponentRoot').ComponentRoot;
components.register('staging', function (args) { return new StagingViewModel(args.server, args.repoPath, args.graph); });
var StagingViewModel = /** @class */ (function (_super) {
    __extends(StagingViewModel, _super);
    function StagingViewModel(server, repoPath, graph) {
        var _this = _super.call(this) || this;
        _this.server = server;
        _this.repoPath = repoPath;
        _this.refreshContent = _.debounce(_this._refreshContent, 250, _this.defaultDebounceOption);
        _this.graph = graph;
        _this.filesByPath = {};
        _this.files = ko.observableArray();
        _this.commitMessageTitleCount = ko.observable(0);
        _this.commitMessageTitle = ko.observable();
        _this.commitMessageTitle.subscribe(function (value) {
            _this.commitMessageTitleCount(value.length);
        });
        _this.commitMessageBody = ko.observable();
        _this.wordWrap = components.create('textdiff.wordwrap');
        _this.textDiffType = components.create('textdiff.type');
        _this.whiteSpace = components.create('textdiff.whitespace');
        _this.inRebase = ko.observable(false);
        _this.inMerge = ko.observable(false);
        _this.inCherry = ko.observable(false);
        _this.conflictText = ko.computed(function () {
            if (_this.inMerge()) {
                _this.conflictContinue = _this.conflictResolution.bind(_this, '/merge/continue');
                _this.conflictAbort = _this.conflictResolution.bind(_this, '/merge/abort');
                return 'Merge';
            }
            else if (_this.inRebase()) {
                _this.conflictContinue = _this.conflictResolution.bind(_this, '/rebase/continue');
                _this.conflictAbort = _this.conflictResolution.bind(_this, '/rebase/abort');
                return 'Rebase';
            }
            else if (_this.inCherry()) {
                _this.conflictContinue = _this.commit;
                _this.conflictAbort = _this.discardAllChanges;
                return 'Cherry-pick';
            }
            else {
                _this.conflictContinue = undefined;
                _this.conflictAbort = undefined;
                return undefined;
            }
        });
        _this.HEAD = ko.observable();
        _this.isStageValid = ko.computed(function () { return !_this.inRebase() && !_this.inMerge() && !_this.inCherry(); });
        _this.nFiles = ko.computed(function () { return _this.files().length; });
        _this.nStagedFiles = ko.computed(function () { return _this.files().filter(function (f) { return f.editState() === 'staged'; }).length; });
        _this.allStageFlag = ko.computed(function () { return _this.nFiles() !== _this.nStagedFiles(); });
        _this.stats = ko.computed(function () { return "".concat(_this.nFiles(), " files, ").concat(_this.nStagedFiles(), " to be commited"); });
        _this.amend = ko.observable(false);
        _this.canAmend = ko.computed(function () { return _this.HEAD() && !_this.inRebase() && !_this.inMerge() && !_this.emptyCommit(); });
        _this.emptyCommit = ko.observable(false);
        _this.canEmptyCommit = ko.computed(function () { return _this.HEAD() && !_this.inRebase() && !_this.inMerge(); });
        _this.canStashAll = ko.computed(function () { return !_this.amend(); });
        _this.canPush = ko.computed(function () { return !!_this.graph.currentRemote(); });
        _this.showNux = ko.computed(function () { return _this.files().length == 0 && !_this.amend() && !_this.inRebase() && !_this.emptyCommit(); });
        _this.showCancelButton = ko.computed(function () { return _this.amend() || _this.emptyCommit(); });
        _this.commitValidationError = ko.computed(function () {
            if (_this.conflictText()) {
                if (_this.files().some(function (file) { return file.conflict(); }))
                    return 'Files in conflict';
            }
            else {
                if (!_this.emptyCommit() &&
                    !_this.amend() &&
                    !_this.files().some(function (file) { return file.editState() === 'staged' || file.editState() === 'patched'; })) {
                    return 'No files to commit';
                }
                if (!_this.commitMessageTitle()) {
                    return 'Provide a title';
                }
                if (_this.textDiffType.value() === 'sidebysidediff') {
                    var patchFiles = _this.files().filter(function (file) { return file.editState() === 'patched'; });
                    if (patchFiles.length > 0)
                        return 'Cannot patch with side by side view.';
                }
            }
            return '';
        });
        _this.toggleSelectAllGlyphClass = ko.computed(function () {
            if (_this.allStageFlag())
                return 'glyphicon-unchecked';
            else
                return 'glyphicon-check';
        });
        _this.refreshContentThrottled = _.throttle(_this.refreshContent.bind(_this), 500, {
            leading: false,
            trailing: true
        });
        _this.invalidateFilesDiffsThrottled = _.throttle(_this.invalidateFilesDiffs.bind(_this), 500, {
            leading: false,
            trailing: true
        });
        _this.refreshContentThrottled();
        _this.loadAnyway = false;
        _this.isDiagOpen = false;
        _this.mutedTime = null;
        _this.discardAllIcon = octicons.trash.toSVG({ height: 15 });
        _this.stashIcon = octicons.pin.toSVG({ height: 15 });
        _this.discardIcon = octicons.x.toSVG({ height: 18 });
        _this.ignoreIcon = octicons.skip.toSVG({ height: 18 });
        return _this;
    }
    StagingViewModel.prototype.updateNode = function (parentElement) {
        ko.renderTemplate('staging', this, {}, parentElement);
    };
    StagingViewModel.prototype.onProgramEvent = function (event) {
        if (event.event == 'request-app-content-refresh' ||
            event.event === 'working-tree-changed' ||
            event.event === 'git-directory-changed') {
            this.refreshContent();
            this.invalidateFilesDiffs();
        }
    };
    StagingViewModel.prototype._refreshContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headPromise, statusPromise, log, array, status_1, err_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ungit.logger.debug('staging.refreshContent() triggered');
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, 5, 6]);
                        headPromise = this.server.getPromise('/head', { path: this.repoPath(), limit: 1 });
                        statusPromise = this.server.getPromise('/status', {
                            path: this.repoPath(),
                            fileLimit: filesToDisplayLimit
                        });
                        return [4 /*yield*/, headPromise];
                    case 2:
                        log = _a.sent();
                        if (log.length > 0) {
                            array = log[0].message.split('\n');
                            this.HEAD({ title: array[0], body: array.slice(2).join('\n') });
                        }
                        else {
                            this.HEAD(null);
                        }
                        return [4 /*yield*/, statusPromise];
                    case 3:
                        status_1 = _a.sent();
                        if (this.isSamePayload(status_1)) {
                            return [2 /*return*/];
                        }
                        if (Object.keys(status_1.files).length > filesToDisplayLimit && !this.loadAnyway) {
                            if (this.isDiagOpen) {
                                return [2 /*return*/];
                            }
                            this.isDiagOpen = true;
                            components.showModal('toomanyfilesmodal', {
                                title: 'Too many unstaged files',
                                details: 'It is recommended to use command line as ungit may be too slow.',
                                closeFunc: function (isYes) {
                                    _this.isDiagOpen = false;
                                    if (isYes) {
                                        window.location.href = '/#/';
                                    }
                                    else {
                                        _this.loadAnyway = true;
                                        _this.loadStatus(status_1);
                                    }
                                }
                            });
                        }
                        else {
                            this.loadStatus(status_1);
                        }
                        return [3 /*break*/, 6];
                    case 4:
                        err_1 = _a.sent();
                        if (err_1.errorCode != 'must-be-in-working-tree' && err_1.errorCode != 'no-such-path') {
                            this.server.unhandledRejection(err_1);
                        }
                        else {
                            ungit.logger.error('error during staging refresh: ', err_1);
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        ungit.logger.debug('staging.refreshContent() finished');
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    StagingViewModel.prototype.loadStatus = function (status) {
        this.setFiles(status.files);
        this.inRebase(!!status.inRebase);
        this.inMerge(!!status.inMerge);
        // There are time where '.git/CHERRY_PICK_HEAD' file is created and no files are in conflicts.
        // in such cases we should ignore exception as no good way to resolve it.
        this.inCherry(!!status.inCherry && !!status.inConflict);
        if (this.inRebase()) {
            this.commitMessageTitle('Rebase conflict');
            this.commitMessageBody('Commit messages are not applicable!\n(╯°□°）╯︵ ┻━┻');
        }
        else if (this.inMerge() || this.inCherry()) {
            var lines = status.commitMessage.split('\n');
            if (!this.commitMessageTitle()) {
                this.commitMessageTitle(lines[0]);
                this.commitMessageBody(lines.slice(1).join('\n'));
            }
        }
    };
    StagingViewModel.prototype.setFiles = function (files) {
        var e_1, _a;
        var newFiles = [];
        try {
            for (var _b = __values(Object.values(files)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var fileStatus = _c.value;
                var fileViewModel = this.filesByPath[fileStatus.fileName];
                if (!fileViewModel) {
                    this.filesByPath[fileStatus.fileName] = fileViewModel = new FileViewModel(this, fileStatus.fileName, fileStatus.oldFileName, fileStatus.displayName);
                }
                else {
                    // this is mainly for patching and it may not fire due to the fact that
                    // '/commit' triggers working-tree-changed which triggers throttled refresh
                    fileViewModel.diff().invalidateDiff();
                }
                fileViewModel.setState(fileStatus);
                newFiles.push(fileViewModel);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.files(newFiles);
    };
    StagingViewModel.prototype.toggleAmend = function () {
        if (!this.amend() && !this.commitMessageTitle()) {
            this.commitMessageTitle(this.HEAD().title);
            this.commitMessageBody(this.HEAD().body);
        }
        else if (this.amend()) {
            var isPrevDefaultMsg = this.commitMessageTitle() == this.HEAD().title &&
                this.commitMessageBody() == this.HEAD().body;
            if (isPrevDefaultMsg) {
                this.commitMessageTitle('');
                this.commitMessageBody('');
            }
        }
        this.amend(!this.amend());
    };
    StagingViewModel.prototype.toggleEmptyCommit = function () {
        this.commitMessageTitle('Empty commit');
        this.commitMessageBody();
        this.emptyCommit(true);
    };
    StagingViewModel.prototype.resetMessages = function () {
        this.commitMessageTitle('');
        this.commitMessageBody('');
        for (var key in this.filesByPath) {
            var element = this.filesByPath[key];
            element.diff().invalidateDiff();
            element.patchLineList.removeAll();
            element.isShowingDiffs(false);
            element.editState(element.editState() === 'patched' ? 'none' : element.editState());
        }
        this.amend(false);
        this.emptyCommit(false);
    };
    StagingViewModel.prototype.commit = function () {
        var _this = this;
        var files = this.files()
            .filter(function (file) { return file.editState() !== 'none'; })
            .map(function (file) { return ({
            name: file.name(),
            patchLineList: file.editState() === 'patched' ? file.patchLineList() : null
        }); });
        var commitMessage = this.commitMessageTitle();
        if (this.commitMessageBody())
            commitMessage += "\n\n".concat(this.commitMessageBody());
        this.server
            .postPromise('/commit', {
            path: this.repoPath(),
            message: commitMessage,
            files: files,
            amend: this.amend(),
            emptyCommit: this.emptyCommit()
        })
            .then(function () {
            _this.resetMessages();
            programEvents.dispatch({ event: 'branch-updated' });
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    StagingViewModel.prototype.commitnpush = function () {
        var _this = this;
        var files = this.files()
            .filter(function (file) { return file.editState() !== 'none'; })
            .map(function (file) { return ({
            name: file.name(),
            patchLineList: file.editState() === 'patched' ? file.patchLineList() : null
        }); });
        var commitMessage = this.commitMessageTitle();
        if (this.commitMessageBody())
            commitMessage += "\n\n".concat(this.commitMessageBody());
        this.server
            .postPromise('/commit', {
            path: this.repoPath(),
            message: commitMessage,
            files: files,
            amend: this.amend(),
            emptyCommit: this.emptyCommit()
        })
            .then(function () {
            _this.resetMessages();
            return _this.server.postPromise('/push', {
                path: _this.repoPath(),
                remote: _this.graph.currentRemote()
            });
        })
            .catch(function (err) {
            if (err.errorCode == 'non-fast-forward') {
                components.showModal('yesnomodal', {
                    title: 'Force push?',
                    details: "The remote branch can't be fast-forwarded.",
                    closeFunc: function (isYes) {
                        if (!isYes)
                            return;
                        _this.server.postPromise('/push', {
                            path: _this.repoPath(),
                            remote: _this.graph.currentRemote(),
                            force: true
                        });
                    }
                });
            }
            else {
                _this.server.unhandledRejection(err);
            }
        });
    };
    StagingViewModel.prototype.conflictResolution = function (apiPath) {
        var _this = this;
        var commitMessage = this.commitMessageTitle();
        if (this.commitMessageBody())
            commitMessage += "\n\n".concat(this.commitMessageBody());
        this.server
            .postPromise(apiPath, { path: this.repoPath(), message: commitMessage })
            .catch(function (e) { return _this.server.unhandledRejection(e); })
            .finally(function () {
            _this.resetMessages();
        });
    };
    StagingViewModel.prototype.invalidateFilesDiffs = function () {
        this.files().forEach(function (file) {
            file.diff().invalidateDiff();
        });
    };
    StagingViewModel.prototype.cancelAmendEmpty = function () {
        this.resetMessages();
    };
    StagingViewModel.prototype.discardAllChanges = function () {
        var _this = this;
        components.showModal('yesnomodal', {
            title: 'Are you sure you want to discard all changes?',
            details: 'This operation cannot be undone.',
            closeFunc: function (isYes) {
                if (!isYes)
                    return;
                _this.server
                    .postPromise('/discardchanges', { path: _this.repoPath(), all: true })
                    .catch(function (e) { return _this.server.unhandledRejection(e); });
            }
        });
    };
    StagingViewModel.prototype.stashAll = function () {
        var _this = this;
        this.server
            .postPromise('/stashes', { path: this.repoPath(), message: this.commitMessageTitle() })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    StagingViewModel.prototype.toggleAllStages = function () {
        var allStageFlag = this.allStageFlag();
        for (var n in this.files()) {
            this.files()[n].editState(allStageFlag ? 'staged' : 'none');
        }
    };
    StagingViewModel.prototype.onEnter = function (d, e) {
        if (e.keyCode === 13 && !this.commitValidationError()) {
            this.commit();
        }
        return true;
    };
    StagingViewModel.prototype.onAltEnter = function (d, e) {
        if (e.keyCode === 13 && e.altKey && !this.commitValidationError()) {
            this.commit();
        }
        return true;
    };
    return StagingViewModel;
}(ComponentRoot));
var FileViewModel = /** @class */ (function () {
    function FileViewModel(staging, name, oldName, displayName) {
        var _this = this;
        this.staging = staging;
        this.server = staging.server;
        this.editState = ko.observable('staged'); // staged, patched and none
        this.name = ko.observable(name);
        this.oldName = ko.observable(oldName);
        this.displayName = ko.observable(displayName);
        this.isNew = ko.observable(false);
        this.removed = ko.observable(false);
        this.conflict = ko.observable(false);
        this.renamed = ko.observable(false);
        this.isShowingDiffs = ko.observable(false);
        this.additions = ko.observable('');
        this.deletions = ko.observable('');
        this.modified = ko.computed(function () {
            // only show modfied whe not removed, not conflicted, not new, not renamed
            // and length of additions and deletions is 0.
            return (!_this.removed() &&
                !_this.conflict() &&
                !_this.isNew() &&
                _this.additions().length === 0 &&
                _this.deletions().length === 0);
        });
        this.fileType = ko.observable('text');
        this.patchLineList = ko.observableArray();
        this.diff = ko.observable();
        this.isShowPatch = ko.computed(function () {
            // if not new file
            // and if not merging
            // and if not rebasing
            // and if text file
            // and if diff is showing, display patch button
            return !_this.isNew() &&
                !staging.inMerge() &&
                !staging.inRebase() &&
                _this.fileType() === 'text' &&
                _this.isShowingDiffs();
        });
        this.mergeTool = ko.computed(function () { return _this.conflict() && mergeTool !== false; });
        this.editState.subscribe(function (value) {
            if (value === 'none') {
                _this.patchLineList.removeAll();
            }
            else if (value === 'patched') {
                if (_this.diff().render)
                    _this.diff().render();
            }
        });
    }
    FileViewModel.prototype.getSpecificDiff = function () {
        return components.create(!this.name() || "".concat(this.fileType(), "diff"), {
            filename: this.name(),
            oldFilename: this.oldName(),
            displayFilename: this.displayName(),
            repoPath: this.staging.repoPath,
            server: this.server,
            textDiffType: this.staging.textDiffType,
            whiteSpace: this.staging.whiteSpace,
            isShowingDiffs: this.isShowingDiffs,
            patchLineList: this.patchLineList,
            editState: this.editState,
            wordWrap: this.staging.wordWrap
        });
    };
    FileViewModel.prototype.setState = function (state) {
        this.displayName(state.displayName);
        this.isNew(state.isNew);
        this.removed(state.removed);
        this.conflict(state.conflict);
        this.renamed(state.renamed);
        this.fileType(state.type);
        this.additions(state.additions != '-' ? "+".concat(state.additions) : '');
        this.deletions(state.deletions != '-' ? "-".concat(state.deletions) : '');
        if (this.diff()) {
            this.diff().invalidateDiff();
        }
        else {
            this.diff(this.getSpecificDiff());
        }
        if (this.diff().isNew)
            this.diff().isNew(state.isNew);
        if (this.diff().isRemoved)
            this.diff().isRemoved(state.removed);
    };
    FileViewModel.prototype.toggleStaged = function () {
        if (this.editState() === 'none') {
            this.editState('staged');
        }
        else {
            this.editState('none');
        }
        this.patchLineList([]);
    };
    FileViewModel.prototype.discardChanges = function () {
        var _this = this;
        var timeSinceLastMute = new Date().getTime() - this.staging.mutedTime;
        var isMuteWarning = timeSinceLastMute < ungit.config.disableDiscardMuteTime;
        ungit.logger.debug("discard time since mute: ".concat(timeSinceLastMute, ", isMuteWarning: ").concat(isMuteWarning));
        if (ungit.config.disableDiscardWarning || isMuteWarning) {
            this.server
                .postPromise('/discardchanges', { path: this.staging.repoPath(), file: this.name() })
                .catch(function (e) { return _this.server.unhandledRejection(e); });
        }
        else {
            components.showModal('yesnomutemodal', {
                title: 'Are you sure you want to discard these changes?',
                details: 'This operation cannot be undone.',
                closeFunc: function (isYes, isMute) {
                    if (isYes) {
                        _this.server
                            .postPromise('/discardchanges', { path: _this.staging.repoPath(), file: _this.name() })
                            .catch(function (e) { return _this.server.unhandledRejection(e); });
                    }
                    if (isMute) {
                        _this.staging.mutedTime = new Date().getTime();
                    }
                }
            });
        }
    };
    FileViewModel.prototype.ignoreFile = function () {
        var _this = this;
        this.server
            .postPromise('/ignorefile', { path: this.staging.repoPath(), file: this.name() })
            .catch(function (err) {
            if (err.errorCode == 'file-already-git-ignored') {
                // The file was already in the .gitignore, so force an update of the staging area (to hopefully clear away this file)
                programEvents.dispatch({ event: 'working-tree-changed' });
            }
            else {
                _this.server.unhandledRejection(err);
            }
        });
    };
    FileViewModel.prototype.resolveConflict = function () {
        var _this = this;
        this.server
            .postPromise('/resolveconflicts', { path: this.staging.repoPath(), files: [this.name()] })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    FileViewModel.prototype.launchMergeTool = function () {
        var _this = this;
        this.server
            .postPromise('/launchmergetool', {
            path: this.staging.repoPath(),
            file: this.name(),
            tool: mergeTool
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    FileViewModel.prototype.toggleDiffs = function () {
        this.isShowingDiffs(!this.isShowingDiffs());
    };
    FileViewModel.prototype.patchClick = function () {
        if (!this.isShowingDiffs())
            return;
        if (this.editState() === 'patched') {
            this.editState('staged');
        }
        else {
            this.editState('patched');
        }
    };
    return FileViewModel;
}());

},{"../ComponentRoot":1,"knockout":undefined,"lodash":undefined,"octicons":undefined,"ungit-components":undefined,"ungit-program-events":undefined}]},{},[2])
//# sourceMappingURL=staging.bundle.js.map
