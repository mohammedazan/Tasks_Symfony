(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var diff2html = require('diff2html');
var sideBySideDiff = 'sidebysidediff';
var textDiff = 'textdiff';
components.register('textdiff', function (args) { return new TextDiffViewModel(args); });
components.register('textdiff.type', function () { return new Type(); });
components.register('textdiff.wordwrap', function () { return new WordWrap(); });
components.register('textdiff.whitespace', function () { return new WhiteSpace(); });
var loadLimit = 100;
var WordWrap = /** @class */ (function () {
    function WordWrap() {
        var _this = this;
        this.value = ko.observable(false);
        this.toggle = function () {
            _this.value(!_this.value());
        };
        this.text = ko.computed(function () { return (_this.value() ? 'Wrap Lines' : 'No Wrap'); });
        this.isActive = ko.computed(function () { return _this.value(); });
    }
    return WordWrap;
}());
var Type = /** @class */ (function () {
    function Type() {
        var _this = this;
        if (!!ungit.config.diffType &&
            ungit.config.diffType !== textDiff &&
            ungit.config.diffType !== sideBySideDiff) {
            ungit.config.diffType = textDiff;
            console.log('Config "diffType" must be either "textdiff" or "sidebysidediff".');
        }
        this.value = ko.observable(ungit.config.diffType || textDiff);
        this.toggle = function () {
            _this.value(_this.value() === textDiff ? sideBySideDiff : textDiff);
        };
        this.text = ko.computed(function () { return (_this.value() === textDiff ? 'Inline' : 'Side By Side'); });
        this.isActive = ko.computed(function () { return _this.value() === sideBySideDiff; });
    }
    return Type;
}());
var WhiteSpace = /** @class */ (function () {
    function WhiteSpace() {
        var _this = this;
        this.value = ko.observable(ungit.config.ignoreWhiteSpaceDiff);
        this.toggle = function () {
            _this.value(!_this.value());
        };
        this.text = ko.computed(function () { return (_this.value() ? 'Show Whitespace' : 'Hide Whitespace'); });
        this.isActive = ko.computed(function () { return _this.value(); });
    }
    return WhiteSpace;
}());
var TextDiffViewModel = /** @class */ (function () {
    function TextDiffViewModel(args) {
        var _this = this;
        this.filename = args.filename;
        this.oldFilename = args.oldFilename;
        this.repoPath = args.repoPath;
        this.server = args.server;
        this.sha1 = args.sha1;
        this.hasMore = ko.observable(false);
        this.diffJson = null;
        this.loadCount = loadLimit;
        this.textDiffType = args.textDiffType;
        this.whiteSpace = args.whiteSpace;
        this.isShowingDiffs = args.isShowingDiffs;
        this.editState = args.editState;
        this.wordWrap = args.wordWrap;
        this.patchLineList = args.patchLineList;
        this.numberOfSelectedPatchLines = 0;
        this.htmlSrc = undefined;
        this.isParsed = ko.observable(false);
        this.isShowingDiffs.subscribe(function (newValue) {
            if (newValue)
                _this.render();
        });
        this.textDiffType.value.subscribe(function () {
            if (_this.isShowingDiffs())
                _this.render();
        });
        this.whiteSpace.value.subscribe(function () {
            if (_this.isShowingDiffs())
                _this.invalidateDiff();
        });
        if (this.isShowingDiffs()) {
            this.render();
        }
    }
    TextDiffViewModel.prototype.updateNode = function (parentElement) {
        ko.renderTemplate('textdiff', this, {}, parentElement);
    };
    TextDiffViewModel.prototype.getDiffArguments = function () {
        return {
            file: this.filename,
            oldFile: this.oldFilename,
            path: this.repoPath(),
            sha1: this.sha1 ? this.sha1 : '',
            whiteSpace: this.whiteSpace.value()
        };
    };
    TextDiffViewModel.prototype.invalidateDiff = function () {
        this.diffJson = null;
        if (this.isShowingDiffs())
            this.render();
    };
    TextDiffViewModel.prototype.getDiffJson = function () {
        var _this = this;
        return this.server
            .getPromise('/diff', this.getDiffArguments())
            .then(function (diffs) {
            if (typeof diffs !== 'string') {
                // Invalid value means there is no changes, show dummy diff without any changes
                diffs = "diff --git a/".concat(_this.filename, " b/").concat(_this.filename, "\n                  index aaaaaaaa..bbbbbbbb 111111\n                  --- a/").concat(_this.filename, "\n                  +++ b/").concat(_this.filename);
            }
            _this.diffJson = diff2html.parse(diffs);
        })
            .catch(function (err) {
            // The file existed before but has been removed, but we're trying to get a diff for it
            // Most likely it will just disappear with the next refresh of the staging area
            // so we just ignore the error here
            if (err.errorCode != 'no-such-file') {
                _this.server.unhandledRejection(err);
            }
            else {
                ungit.logger.warn('diff, no such file', err);
            }
        });
    };
    TextDiffViewModel.prototype.render = function () {
        var _this = this;
        return (!this.diffJson ? this.getDiffJson() : Promise.resolve()).then(function () {
            if (!_this.diffJson || _this.diffJson.length == 0)
                return; // check if diffs are available (binary files do not support them)
            if (!_this.diffJson[0].allBlocks) {
                _this.diffJson[0].allBlocks = _this.diffJson[0].blocks;
            }
            var currentLoadCount = Math.max(_this.loadCount, loadLimit);
            var lineCount = 0;
            var loadCount = 0;
            _this.diffJson[0].blocks = _this.diffJson[0].allBlocks.reduce(function (blocks, block) {
                var length = block.lines.length;
                var remaining = currentLoadCount - lineCount;
                if (remaining > 0) {
                    loadCount += length;
                    blocks.push(block);
                }
                lineCount += length;
                return blocks;
            }, []);
            _this.loadCount = loadCount;
            _this.hasMore(lineCount > loadCount);
            var html = diff2html.html(_this.diffJson, {
                outputFormat: _this.textDiffType.value() === sideBySideDiff ? 'side-by-side' : 'line-by-line',
                drawFileList: false
            });
            _this.numberOfSelectedPatchLines = 0;
            var index = 0;
            // ko's binding resolution is not recursive, which means below ko.bind refresh method doesn't work for
            // data bind at getPatchCheckBox that is rendered with "html" binding.
            // which is reason why manually updating the html content and refreshing kobinding to have it render...
            if (_this.patchLineList) {
                html = html.replace(/<span class="d2h-code-line-prefix">(\+|-)/g, function (match, capture) {
                    if (_this.patchLineList()[index] === undefined) {
                        _this.patchLineList()[index] = true;
                    }
                    return _this.getPatchCheckBox(capture, index, _this.patchLineList()[index++]);
                });
            }
            if (html !== _this.htmlSrc) {
                // diff has changed since last we displayed and need refresh
                _this.htmlSrc = html;
                _this.isParsed(false);
                _this.isParsed(true);
            }
        });
    };
    TextDiffViewModel.prototype.loadMore = function () {
        this.loadCount += loadLimit;
        this.render();
    };
    TextDiffViewModel.prototype.getPatchCheckBox = function (symbol, index, isActive) {
        if (isActive) {
            this.numberOfSelectedPatchLines++;
        }
        return "<span class=\"d2h-code-line-prefix\"><span data-bind=\"visible: editState() !== 'patched'\">".concat(symbol, "</span><input ").concat(isActive ? 'checked' : '', " type=\"checkbox\" data-bind=\"visible: editState() === 'patched', click: togglePatchLine.bind($data, ").concat(index, ")\">");
    };
    TextDiffViewModel.prototype.togglePatchLine = function (index) {
        this.patchLineList()[index] = !this.patchLineList()[index];
        if (this.patchLineList()[index]) {
            this.numberOfSelectedPatchLines++;
        }
        else {
            this.numberOfSelectedPatchLines--;
        }
        if (this.numberOfSelectedPatchLines === 0) {
            this.editState('none');
        }
        return true;
    };
    return TextDiffViewModel;
}());

},{"diff2html":undefined,"knockout":undefined,"ungit-components":undefined}]},{},[1])
//# sourceMappingURL=textdiff.bundle.js.map
