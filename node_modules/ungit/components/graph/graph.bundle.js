(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentRoot = void 0;
var ComponentRoot = /** @class */ (function () {
    function ComponentRoot() {
        this.defaultDebounceOption = {
            maxWait: 1500,
            leading: false,
            trailing: true
        };
    }
    ComponentRoot.prototype.isSamePayload = function (value) {
        var jsonString = JSON.stringify(value);
        if (this._apiCache === jsonString) {
            ungit.logger.debug("ignoring redraw for same ".concat(this.constructor.name, " payload."));
            return true;
        }
        ungit.logger.debug("redrawing ".concat(this.constructor.name, " payload.  \n").concat(jsonString));
        this._apiCache = jsonString;
        return false;
    };
    ComponentRoot.prototype.clearApiCache = function () {
        this._apiCache = undefined;
    };
    return ComponentRoot;
}());
exports.ComponentRoot = ComponentRoot;

},{}],2:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ko = require('knockout');
var Selectable = require('./selectable');
require('mina');
var Animateable = /** @class */ (function (_super) {
    __extends(Animateable, _super);
    function Animateable(graph) {
        var _this = _super.call(this, graph) || this;
        _this.element = ko.observable();
        _this.previousGraph = undefined;
        _this.element.subscribe(function (val) {
            if (val)
                _this.animate(true);
        });
        _this.animate = function (forceRefresh) {
            var currentGraph = _this.getGraphAttr();
            if (_this.element() &&
                (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(_this.previousGraph))) {
                // dom is valid and force refresh is requested or dom moved, redraw
                if (ungit.config.isAnimate) {
                    var now = Date.now();
                    window.mina(_this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, function (val) {
                        _this.setGraphAttr(val);
                    }, window.mina.elastic);
                }
                else {
                    _this.setGraphAttr(currentGraph);
                }
                _this.previousGraph = currentGraph;
            }
        };
        return _this;
    }
    return Animateable;
}(Selectable));
module.exports = Animateable;

},{"./selectable":9,"knockout":undefined,"mina":undefined}],3:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ko = require('knockout');
var Animateable = require('./animateable');
var EdgeViewModel = /** @class */ (function (_super) {
    __extends(EdgeViewModel, _super);
    function EdgeViewModel(graph, nodeAsha1, nodeBsha1) {
        var _this = _super.call(this, graph) || this;
        _this.nodeA = graph.getNode(nodeAsha1);
        _this.nodeB = graph.getNode(nodeBsha1);
        _this.getGraphAttr = ko.computed(function () {
            if (_this.nodeA.isViewable() && (!_this.nodeB.isViewable() || !_this.nodeB.isInited)) {
                return [
                    _this.nodeA.cx(),
                    _this.nodeA.cy(),
                    _this.nodeA.cx(),
                    _this.nodeA.cy(),
                    _this.nodeA.cx(),
                    graph.graphHeight(),
                    _this.nodeA.cx(),
                    graph.graphHeight(),
                ];
            }
            else if (_this.nodeB.isInited && _this.nodeB.cx() && _this.nodeB.cy()) {
                return [
                    _this.nodeA.cx(),
                    _this.nodeA.cy(),
                    _this.nodeA.cx(),
                    _this.nodeA.cy(),
                    _this.nodeB.cx(),
                    _this.nodeB.cy(),
                    _this.nodeB.cx(),
                    _this.nodeB.cy(),
                ];
            }
            else {
                return [0, 0, 0, 0, 0, 0, 0, 0];
            }
        });
        _this.getGraphAttr.subscribe(_this.animate.bind(_this));
        return _this;
    }
    EdgeViewModel.prototype.setGraphAttr = function (val) {
        this.element().setAttribute('d', "M".concat(val.slice(0, 4).join(','), "L").concat(val.slice(4, 8).join(',')));
    };
    EdgeViewModel.prototype.edgeMouseOver = function () {
        if (this.nodeA) {
            this.nodeA.isEdgeHighlighted(true);
        }
        if (this.nodeB) {
            this.nodeB.isEdgeHighlighted(true);
        }
    };
    EdgeViewModel.prototype.edgeMouseOut = function () {
        if (this.nodeA) {
            this.nodeA.isEdgeHighlighted(false);
        }
        if (this.nodeB) {
            this.nodeB.isEdgeHighlighted(false);
        }
    };
    return EdgeViewModel;
}(Animateable));
module.exports = EdgeViewModel;

},{"./animateable":2,"knockout":undefined}],4:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ko = require('knockout');
var octicons = require('octicons');
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var RefViewModel = require('./git-ref.js');
var HoverActions = require('./hover-actions');
var RebaseViewModel = HoverActions.RebaseViewModel;
var MergeViewModel = HoverActions.MergeViewModel;
var ResetViewModel = HoverActions.ResetViewModel;
var PushViewModel = HoverActions.PushViewModel;
var SquashViewModel = HoverActions.SquashViewModel;
var ActionBase = /** @class */ (function () {
    function ActionBase(graph, text, style, icon) {
        var _this = this;
        this.graph = graph;
        this.server = graph.server;
        this.isRunning = ko.observable(false);
        this.isHighlighted = ko.computed(function () { return !graph.hoverGraphAction() || graph.hoverGraphAction() == _this; });
        this.text = text;
        this.style = style;
        this.icon = icon;
        this.cssClasses = ko.computed(function () {
            if (!_this.isHighlighted() || _this.isRunning()) {
                return "".concat(_this.style, " dimmed");
            }
            else {
                return _this.style;
            }
        });
    }
    ActionBase.prototype.doPerform = function () {
        var _this = this;
        if (this.isRunning())
            return;
        this.graph.hoverGraphAction(null);
        this.isRunning(true);
        return this.perform()
            .catch(function (e) { return _this.server.unhandledRejection(e); })
            .finally(function () {
            _this.isRunning(false);
        });
    };
    ActionBase.prototype.dragEnter = function () {
        if (!this.visible())
            return;
        this.graph.hoverGraphAction(this);
    };
    ActionBase.prototype.dragLeave = function () {
        if (!this.visible())
            return;
        this.graph.hoverGraphAction(null);
    };
    ActionBase.prototype.mouseover = function () {
        this.graph.hoverGraphAction(this);
    };
    ActionBase.prototype.mouseout = function () {
        this.graph.hoverGraphAction(null);
    };
    return ActionBase;
}());
var Move = /** @class */ (function (_super) {
    __extends(Move, _super);
    function Move(graph, node) {
        var _this = _super.call(this, graph, 'Move', 'move', octicons['arrow-left'].toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                _this.graph.currentActionContext().node() != _this.node);
        });
        return _this;
    }
    Move.prototype.perform = function () {
        return this.graph.currentActionContext().moveTo(this.node.sha1);
    };
    return Move;
}(ActionBase));
var Reset = /** @class */ (function (_super) {
    __extends(Reset, _super);
    function Reset(graph, node) {
        var _this = _super.call(this, graph, 'Reset', 'reset', octicons.trash.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            if (!(_this.graph.currentActionContext() instanceof RefViewModel))
                return false;
            var context = _this.graph.currentActionContext();
            if (context.node() != _this.node)
                return false;
            var remoteRef = context.getRemoteRef(_this.graph.currentRemote());
            return (remoteRef &&
                remoteRef.node() &&
                context &&
                context.node() &&
                remoteRef.node() != context.node() &&
                remoteRef.node().date < context.node().date);
        });
        return _this;
    }
    Reset.prototype.createHoverGraphic = function () {
        var context = this.graph.currentActionContext();
        if (!context)
            return null;
        var remoteRef = context.getRemoteRef(this.graph.currentRemote());
        var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
        return new ResetViewModel(nodes);
    };
    Reset.prototype.perform = function () {
        var _this = this;
        var context = this.graph.currentActionContext();
        var remoteRef = context.getRemoteRef(this.graph.currentRemote());
        return new Promise(function (resolve, reject) {
            components.showModal('yesnomodal', {
                title: 'Are you sure?',
                details: 'Resetting to ref: ' + remoteRef.name + ' cannot be undone with ungit.',
                closeFunc: function (isYes) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!isYes) return [3 /*break*/, 2];
                                return [4 /*yield*/, this.server
                                        .postPromise('/reset', {
                                        path: this.graph.repoPath(),
                                        to: remoteRef.name,
                                        mode: 'hard'
                                    })
                                        .then(resolve)
                                        .catch(reject)];
                            case 1:
                                _a.sent();
                                context.node(remoteRef.node());
                                _a.label = 2;
                            case 2:
                                this.isRunning(false);
                                return [2 /*return*/];
                        }
                    });
                }); }
            });
        });
    };
    return Reset;
}(ActionBase));
var Rebase = /** @class */ (function (_super) {
    __extends(Rebase, _super);
    function Rebase(graph, node) {
        var _this = _super.call(this, graph, 'Rebase', 'rebase', octicons['repo-forked'].toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                (!ungit.config.showRebaseAndMergeOnlyOnRefs || _this.node.refs().length > 0) &&
                _this.graph.currentActionContext().current() &&
                _this.graph.currentActionContext().node() != _this.node);
        });
        return _this;
    }
    Rebase.prototype.createHoverGraphic = function () {
        var onto = this.graph.currentActionContext();
        if (!onto)
            return;
        if (onto instanceof RefViewModel)
            onto = onto.node();
        var path = onto.getPathToCommonAncestor(this.node);
        return new RebaseViewModel(this.node, path);
    };
    Rebase.prototype.perform = function () {
        var _this = this;
        return this.server
            .postPromise('/rebase', { path: this.graph.repoPath(), onto: this.node.sha1 })
            .catch(function (err) {
            if (err.errorCode != 'merge-failed') {
                _this.server.unhandledRejection(err);
            }
            else {
                ungit.logger.warn('rebase failed', err);
            }
        });
    };
    return Rebase;
}(ActionBase));
var Merge = /** @class */ (function (_super) {
    __extends(Merge, _super);
    function Merge(graph, node) {
        var _this = _super.call(this, graph, 'Merge', 'merge', octicons['git-merge'].toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            if (!_this.graph.checkedOutRef() || !_this.graph.checkedOutRef().node())
                return false;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                !_this.graph.currentActionContext().current() &&
                _this.graph.checkedOutRef().node() == _this.node);
        });
        return _this;
    }
    Merge.prototype.createHoverGraphic = function () {
        var node = this.graph.currentActionContext();
        if (!node)
            return null;
        if (node instanceof RefViewModel)
            node = node.node();
        return new MergeViewModel(this.graph, this.node, node);
    };
    Merge.prototype.perform = function () {
        var _this = this;
        return this.server
            .postPromise('/merge', {
            path: this.graph.repoPath(),
            with: this.graph.currentActionContext().localRefName
        })
            .catch(function (err) {
            if (err.errorCode != 'merge-failed') {
                _this.server.unhandledRejection(err);
            }
            else {
                ungit.logger.warn('merge failed', err);
            }
        });
    };
    return Merge;
}(ActionBase));
var Push = /** @class */ (function (_super) {
    __extends(Push, _super);
    function Push(graph, node) {
        var _this = _super.call(this, graph, 'Push', 'push', octicons['repo-push'].toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                _this.graph.currentActionContext().node() == _this.node &&
                _this.graph.currentActionContext().canBePushed(_this.graph.currentRemote()));
        });
        return _this;
    }
    Push.prototype.createHoverGraphic = function () {
        var context = this.graph.currentActionContext();
        if (!context)
            return null;
        var remoteRef = context.getRemoteRef(this.graph.currentRemote());
        if (!remoteRef)
            return null;
        return new PushViewModel(remoteRef.node(), context.node());
    };
    Push.prototype.perform = function () {
        var _this = this;
        var ref = this.graph.currentActionContext();
        var remoteRef = ref.getRemoteRef(this.graph.currentRemote());
        if (remoteRef) {
            return remoteRef.moveTo(ref.node().sha1);
        }
        else {
            return ref
                .createRemoteRef()
                .then(function () {
                if (_this.graph.HEAD().name == ref.name) {
                    _this.graph.HEADref().node(ref.node());
                }
            })
                .finally(function () { return programEvents.dispatch({ event: 'request-fetch-tags' }); });
        }
    };
    return Push;
}(ActionBase));
var Checkout = /** @class */ (function (_super) {
    __extends(Checkout, _super);
    function Checkout(graph, node) {
        var _this = _super.call(this, graph, 'Checkout', 'checkout', octicons['desktop-download'].toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            if (_this.graph.currentActionContext() instanceof RefViewModel)
                return (_this.graph.currentActionContext().node() == _this.node &&
                    !_this.graph.currentActionContext().current());
            return ungit.config.allowCheckoutNodes && _this.graph.currentActionContext() == _this.node;
        });
        return _this;
    }
    Checkout.prototype.perform = function () {
        return this.graph.currentActionContext().checkout();
    };
    return Checkout;
}(ActionBase));
var Delete = /** @class */ (function (_super) {
    __extends(Delete, _super);
    function Delete(graph, node) {
        var _this = _super.call(this, graph, 'Delete', 'delete', octicons.x.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                _this.graph.currentActionContext().node() == _this.node &&
                !_this.graph.currentActionContext().current());
        });
        return _this;
    }
    Delete.prototype.perform = function () {
        var _this = this;
        var context = this.graph.currentActionContext();
        var details = "\"".concat(context.refName, "\"");
        if (context.isRemoteBranch) {
            details = "<code _style=\"font-size: 100%\">REMOTE</code> ".concat(details);
        }
        details = "Deleting ".concat(details, " branch or tag cannot be undone with ungit.");
        return new Promise(function (resolve, reject) {
            components.showModal('yesnomodal', {
                title: 'Are you sure?',
                details: details,
                closeFunc: function (isYes) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!isYes) return [3 /*break*/, 2];
                                return [4 /*yield*/, context.remove().then(resolve).catch(reject)];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2:
                                this.isRunning(false);
                                return [2 /*return*/];
                        }
                    });
                }); }
            });
        });
    };
    return Delete;
}(ActionBase));
var CherryPick = /** @class */ (function (_super) {
    __extends(CherryPick, _super);
    function CherryPick(graph, node) {
        var _this = _super.call(this, graph, 'Cherry pick', 'cherry-pick', octicons.cpu.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            var context = _this.graph.currentActionContext();
            return context === _this.node && _this.graph.HEAD() && context.sha1 !== _this.graph.HEAD().sha1;
        });
        return _this;
    }
    CherryPick.prototype.perform = function () {
        var _this = this;
        return this.server
            .postPromise('/cherrypick', { path: this.graph.repoPath(), name: this.node.sha1 })
            .catch(function (err) {
            if (err.errorCode != 'merge-failed') {
                _this.server.unhandledRejection(err);
            }
            else {
                ungit.logger.warn('cherrypick failed', err);
            }
        });
    };
    return CherryPick;
}(ActionBase));
var Uncommit = /** @class */ (function (_super) {
    __extends(Uncommit, _super);
    function Uncommit(graph, node) {
        var _this = _super.call(this, graph, 'Uncommit', 'uncommit', octicons.zap.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return _this.graph.currentActionContext() == _this.node && _this.graph.HEAD() == _this.node;
        });
        return _this;
    }
    Uncommit.prototype.perform = function () {
        var _this = this;
        return this.server
            .postPromise('/reset', { path: this.graph.repoPath(), to: 'HEAD^', mode: 'mixed' })
            .then(function () {
            var targetNode = _this.node.belowNode;
            while (targetNode && !targetNode.ancestorOfHEAD()) {
                targetNode = targetNode.belowNode;
            }
            _this.graph.HEADref().node(targetNode ? targetNode : null);
            _this.graph.checkedOutRef().node(targetNode ? targetNode : null);
        });
    };
    return Uncommit;
}(ActionBase));
var Revert = /** @class */ (function (_super) {
    __extends(Revert, _super);
    function Revert(graph, node) {
        var _this = _super.call(this, graph, 'Revert', 'revert', octicons.history.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return _this.graph.currentActionContext() == _this.node;
        });
        return _this;
    }
    Revert.prototype.perform = function () {
        return this.server.postPromise('/revert', {
            path: this.graph.repoPath(),
            commit: this.node.sha1
        });
    };
    return Revert;
}(ActionBase));
var Squash = /** @class */ (function (_super) {
    __extends(Squash, _super);
    function Squash(graph, node) {
        var _this = _super.call(this, graph, 'Squash', 'squash', octicons.fold.toSVG({ height: 18 })) || this;
        _this.node = node;
        _this.visible = ko.computed(function () {
            if (_this.isRunning())
                return true;
            return (_this.graph.currentActionContext() instanceof RefViewModel &&
                _this.graph.currentActionContext().current() &&
                _this.graph.currentActionContext().node() != _this.node);
        });
        return _this;
    }
    Squash.prototype.createHoverGraphic = function () {
        var onto = this.graph.currentActionContext();
        if (!onto)
            return;
        if (onto instanceof RefViewModel)
            onto = onto.node();
        return new SquashViewModel(this.node, onto);
    };
    Squash.prototype.perform = function () {
        var _this = this;
        var onto = this.graph.currentActionContext();
        if (!onto)
            return;
        if (onto instanceof RefViewModel)
            onto = onto.node();
        // remove last element as it would be a common ancestor.
        var path = this.node.getPathToCommonAncestor(onto).slice(0, -1);
        if (path.length > 0) {
            // squashing branched out lineage
            // c is checkout with squash target of e, results in staging changes
            // from d and e on top of c
            //
            // a - b - (c)        a - b - (c) - [de]
            //  \           ->     \
            //   d  - <e>           d - <e>
            return this.server.postPromise('/squash', {
                path: this.graph.repoPath(),
                target: this.node.sha1
            });
        }
        else {
            // squashing backward from same lineage
            // c is checkout with squash target of a, results in current ref moved
            // to a and staging changes within b and c on top of a
            //
            // <a> - b - (c)       (a) - b - c
            //                ->     \
            //                        [bc]
            return this.graph
                .currentActionContext()
                .moveTo(this.node.sha1, true)
                .then(function () {
                return _this.server.postPromise('/squash', { path: _this.graph.repoPath(), target: onto.sha1 });
            });
        }
    };
    return Squash;
}(ActionBase));
var GraphActions = {
    Move: Move,
    Rebase: Rebase,
    Merge: Merge,
    Push: Push,
    Reset: Reset,
    Checkout: Checkout,
    Delete: Delete,
    CherryPick: CherryPick,
    Uncommit: Uncommit,
    Revert: Revert,
    Squash: Squash
};
module.exports = GraphActions;

},{"./git-ref.js":6,"./hover-actions":8,"knockout":undefined,"octicons":undefined,"ungit-components":undefined,"ungit-program-events":undefined}],5:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var $ = require('jquery');
var ko = require('knockout');
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var Animateable = require('./animateable');
var GraphActions = require('./git-graph-actions');
var maxBranchesToDisplay = parseInt((ungit.config.numRefsToShow / 5) * 3); // 3/5 of refs to show to branches
var maxTagsToDisplay = ungit.config.numRefsToShow - maxBranchesToDisplay; // 2/5 of refs to show to tags
var GitNodeViewModel = /** @class */ (function (_super) {
    __extends(GitNodeViewModel, _super);
    function GitNodeViewModel(graph, sha1) {
        var _this = _super.call(this, graph) || this;
        _this.graph = graph;
        _this.sha1 = sha1;
        _this.isInited = false;
        _this.title = ko.observable();
        _this.parents = ko.observableArray();
        _this.commitTime = undefined; // commit time in string
        _this.date = undefined; // commit time in numeric format for sort
        _this.color = ko.observable();
        _this.ideologicalBranch = ko.observable();
        _this.remoteTags = ko.observableArray();
        _this.branchesAndLocalTags = ko.observableArray();
        _this.signatureDate = ko.observable();
        _this.signatureMade = ko.observable();
        _this.pgpVerifiedString = ko.computed(function () {
            if (_this.signatureMade()) {
                return "PGP by: ".concat(_this.signatureMade(), " at ").concat(_this.signatureDate());
            }
        });
        _this.refs = ko.computed(function () {
            var rs = _this.branchesAndLocalTags().concat(_this.remoteTags());
            rs.sort(function (a, b) {
                if (b.current())
                    return 1;
                if (a.current())
                    return -1;
                if (a.isLocal && !b.isLocal)
                    return -1;
                if (!a.isLocal && b.isLocal)
                    return 1;
                return a.refName < b.refName ? -1 : 1;
            });
            return rs;
        });
        // These are split up like this because branches and local tags can be found in the git log,
        // whereas remote tags needs to be fetched with another command (which is much slower)
        _this.branches = ko.observableArray();
        _this.branchesToDisplay = ko.observableArray();
        _this.tags = ko.observableArray();
        _this.tagsToDisplay = ko.observableArray();
        _this.refs.subscribe(function (newValue) {
            if (newValue) {
                _this.branches(newValue.filter(function (r) { return r.isBranch; }));
                _this.tags(newValue.filter(function (r) { return r.isTag; }));
                _this.branchesToDisplay(_this.branches.slice(0, ungit.config.numRefsToShow - Math.min(_this.tags().length, maxTagsToDisplay)));
                _this.tagsToDisplay(_this.tags.slice(0, ungit.config.numRefsToShow - _this.branchesToDisplay().length));
            }
            else {
                _this.branches.removeAll();
                _this.tags.removeAll();
                _this.branchesToDisplay.removeAll();
                _this.tagsToDisplay.removeAll();
            }
        });
        _this.ancestorOfHEAD = ko.observable(false);
        _this.nodeIsMousehover = ko.observable(false);
        _this.commitContainerVisible = ko.computed(function () { return _this.ancestorOfHEAD() || _this.nodeIsMousehover() || _this.selected(); });
        _this.isEdgeHighlighted = ko.observable(false);
        // for small empty black circle to highlight a node
        _this.isNodeAccented = ko.computed(function () { return _this.selected() || _this.isEdgeHighlighted(); });
        // to show changed files and diff boxes on the left of node
        _this.highlighted = ko.computed(function () { return _this.nodeIsMousehover() || _this.selected(); });
        _this.selected.subscribe(function () {
            programEvents.dispatch({ event: 'graph-render' });
        });
        _this.showNewRefAction = ko.computed(function () { return !graph.currentActionContext(); });
        _this.showRefSearch = ko.computed(function () { return _this.branches().length + _this.tags().length > ungit.config.numRefsToShow; });
        _this.newBranchName = ko.observable();
        _this.newBranchNameHasFocus = ko.observable(true);
        _this.branchingFormVisible = ko.observable(false);
        _this.canCreateRef = ko.computed(function () {
            return _this.newBranchName() && _this.newBranchName().trim() && !_this.newBranchName().includes(' ');
        });
        _this.branchOrder = ko.observable();
        _this.aboveNode = undefined;
        _this.belowNode = undefined;
        _this.refSearchFormVisible = ko.observable(false);
        _this.commitComponent = components.create('commit', _this);
        _this.r = ko.observable();
        _this.cx = ko.observable();
        _this.cy = ko.observable();
        _this.dropareaGraphActions = [
            new GraphActions.Move(_this.graph, _this),
            new GraphActions.Rebase(_this.graph, _this),
            new GraphActions.Merge(_this.graph, _this),
            new GraphActions.Push(_this.graph, _this),
            new GraphActions.Reset(_this.graph, _this),
            new GraphActions.Checkout(_this.graph, _this),
            new GraphActions.Delete(_this.graph, _this),
            new GraphActions.CherryPick(_this.graph, _this),
            new GraphActions.Uncommit(_this.graph, _this),
            new GraphActions.Revert(_this.graph, _this),
            new GraphActions.Squash(_this.graph, _this),
        ];
        return _this;
    }
    GitNodeViewModel.prototype.getGraphAttr = function () {
        return [this.cx(), this.cy()];
    };
    GitNodeViewModel.prototype.setGraphAttr = function (val) {
        this.element().setAttribute('x', val[0] - 30);
        this.element().setAttribute('y', val[1] - 30);
    };
    GitNodeViewModel.prototype.render = function () {
        this.refSearchFormVisible(false);
        if (!this.isInited)
            return;
        if (this.ancestorOfHEAD()) {
            this.r(30);
            this.cx(610);
            if (!this.aboveNode) {
                this.cy(120);
            }
            else if (this.aboveNode.ancestorOfHEAD()) {
                this.cy(this.aboveNode.cy() + 120);
            }
            else {
                this.cy(this.aboveNode.cy() + 60);
            }
        }
        else {
            this.r(15);
            this.cx(610 + 90 * this.branchOrder());
            this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
        }
        if (this.aboveNode && this.aboveNode.selected()) {
            this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
        }
        this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
        this.animate();
    };
    GitNodeViewModel.prototype.setData = function (logEntry) {
        var _this = this;
        this.title(logEntry.message.split('\n')[0]);
        this.parents(logEntry.parents || []);
        this.commitTime = logEntry.commitDate;
        this.date = Date.parse(this.commitTime);
        this.commitComponent.setData(logEntry);
        this.signatureMade(logEntry.signatureMade);
        this.signatureDate(logEntry.signatureDate);
        (logEntry.refs || []).forEach(function (ref) {
            _this.graph.getRef(ref).node(_this);
        });
        this.isInited = true;
    };
    GitNodeViewModel.prototype.showBranchingForm = function () {
        this.branchingFormVisible(true);
        this.newBranchNameHasFocus(true);
    };
    GitNodeViewModel.prototype.showRefSearchForm = function (obj, event) {
        var _this = this;
        this.refSearchFormVisible(true);
        var textBox = event.currentTarget.parentElement.querySelector('input[type="search"]');
        var $textBox = $(textBox);
        if (!$textBox.autocomplete('instance')) {
            var renderItem_1 = function (ul, item) { return $("<li><a>".concat(item.displayHtml(), "</a></li>")).appendTo(ul); };
            $textBox.autocomplete({
                classes: {
                    'ui-autocomplete': 'dropdown-menu'
                },
                source: this.refs().filter(function (ref) { return !ref.isHEAD; }),
                minLength: 0,
                create: function (event) {
                    $(event.target).data('ui-autocomplete')._renderItem = renderItem_1;
                },
                select: function (_event, ui) {
                    var ref = ui.item;
                    var ray = ref.isTag ? _this.tagsToDisplay : _this.branchesToDisplay;
                    // if ref is in display, remove it, else remove last in array.
                    ray.splice(ray.indexOf(ref), 1);
                    ray.unshift(ref);
                    _this.refSearchFormVisible(false);
                    // Clear search input on selection
                    return false;
                }
            });
            $textBox.on('focus', function (event) {
                $(event.target).autocomplete('search', event.target.value);
            });
            $textBox.autocomplete('search', '');
        }
    };
    GitNodeViewModel.prototype.createBranch = function () {
        var _this = this;
        if (!this.canCreateRef())
            return;
        this.graph.server
            .postPromise('/branches', {
            path: this.graph.repoPath(),
            name: this.newBranchName(),
            sha1: this.sha1
        })
            .then(function () {
            _this.graph.getRef("refs/heads/".concat(_this.newBranchName())).node(_this);
            if (ungit.config.autoCheckoutOnBranchCreate) {
                return _this.graph.server.postPromise('/checkout', {
                    path: _this.graph.repoPath(),
                    name: _this.newBranchName()
                });
            }
        })
            .catch(function (e) { return _this.graph.server.unhandledRejection(e); })
            .finally(function () {
            _this.branchingFormVisible(false);
            _this.newBranchName('');
            programEvents.dispatch({ event: 'branch-updated' });
        });
    };
    GitNodeViewModel.prototype.createTag = function () {
        var _this = this;
        if (!this.canCreateRef())
            return;
        this.graph.server
            .postPromise('/tags', {
            path: this.graph.repoPath(),
            name: this.newBranchName(),
            sha1: this.sha1
        })
            .then(function () { return _this.graph.getRef("refs/tags/".concat(_this.newBranchName())).node(_this); })
            .catch(function (e) { return _this.graph.server.unhandledRejection(e); })
            .finally(function () {
            _this.branchingFormVisible(false);
            _this.newBranchName('');
        });
    };
    GitNodeViewModel.prototype.toggleSelected = function () {
        var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
        var beforeBelowCR = null;
        if (this.belowNode) {
            beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
        }
        var prevSelected = this.graph.currentActionContext();
        if (!(prevSelected instanceof GitNodeViewModel))
            prevSelected = null;
        var prevSelectedCR = prevSelected
            ? prevSelected.commitComponent.element().getBoundingClientRect()
            : null;
        this.selected(!this.selected());
        // If we are deselecting
        if (!this.selected()) {
            if (beforeThisCR.top < 0 && beforeBelowCR) {
                var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
                // If the next node is showing, try to keep it in the screen (no jumping)
                if (beforeBelowCR.top < window.innerHeight) {
                    window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
                    // Otherwise just try to bring them to the middle of the screen
                }
                else {
                    window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
                }
            }
            // If we are selecting
        }
        else {
            var afterThisCR = this.commitComponent.element().getBoundingClientRect();
            if (prevSelectedCR &&
                (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight) &&
                afterThisCR.top != beforeThisCR.top) {
                window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
                console.log('Fix');
            }
        }
        return false;
    };
    GitNodeViewModel.prototype.removeRef = function (ref) {
        if (ref.isRemoteTag) {
            this.remoteTags.remove(ref);
        }
        else {
            this.branchesAndLocalTags.remove(ref);
        }
    };
    GitNodeViewModel.prototype.pushRef = function (ref) {
        if (ref.isRemoteTag && !this.remoteTags().includes(ref)) {
            this.remoteTags.push(ref);
        }
        else if (!this.branchesAndLocalTags().includes(ref)) {
            this.branchesAndLocalTags.push(ref);
        }
    };
    GitNodeViewModel.prototype.updateAnimationFrame = function (deltaT) {
        this.commitComponent.updateAnimationFrame(deltaT);
    };
    GitNodeViewModel.prototype.getPathToCommonAncestor = function (node) {
        var path = [];
        var thisNode = this;
        while (thisNode && !node.isAncestor(thisNode)) {
            path.push(thisNode);
            thisNode = this.graph.nodesById[thisNode.parents()[0]];
        }
        if (thisNode)
            path.push(thisNode);
        return path;
    };
    GitNodeViewModel.prototype.isAncestor = function (node) {
        if (node == this)
            return true;
        for (var v in this.parents()) {
            var n = this.graph.nodesById[this.parents()[v]];
            if (n && n.isAncestor(node))
                return true;
        }
        return false;
    };
    GitNodeViewModel.prototype.getRightToLeftStrike = function () {
        return "M ".concat(this.cx() - 30, " ").concat(this.cy() - 30, " L ").concat(this.cx() + 30, " ").concat(this.cy() + 30);
    };
    GitNodeViewModel.prototype.getLeftToRightStrike = function () {
        return "M ".concat(this.cx() + 30, " ").concat(this.cy() - 30, " L ").concat(this.cx() - 30, " ").concat(this.cy() + 30);
    };
    GitNodeViewModel.prototype.nodeMouseover = function () {
        this.nodeIsMousehover(true);
    };
    GitNodeViewModel.prototype.nodeMouseout = function () {
        this.nodeIsMousehover(false);
    };
    GitNodeViewModel.prototype.isViewable = function () {
        return this.graph.nodes().includes(this);
    };
    return GitNodeViewModel;
}(Animateable));
module.exports = GitNodeViewModel;

},{"./animateable":2,"./git-graph-actions":4,"jquery":undefined,"knockout":undefined,"ungit-components":undefined,"ungit-program-events":undefined}],6:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ko = require('knockout');
var md5 = require('blueimp-md5');
var octicons = require('octicons');
var programEvents = require('ungit-program-events');
var components = require('ungit-components');
var Selectable = require('./selectable');
var RefViewModel = /** @class */ (function (_super) {
    __extends(RefViewModel, _super);
    function RefViewModel(fullRefName, graph) {
        var _this = _super.call(this, graph) || this;
        _this.graph = graph;
        _this.name = fullRefName;
        _this.node = ko.observable();
        _this.localRefName = _this.name; // origin/master or master
        _this.refName = _this.name; // master
        _this.isRemoteTag = _this.name.indexOf('remote-tag: ') == 0;
        _this.isLocalTag = _this.name.indexOf('tag: ') == 0;
        _this.isTag = _this.isLocalTag || _this.isRemoteTag;
        var isRemoteBranchOrHEAD = _this.name.indexOf('refs/remotes/') == 0;
        _this.isLocalHEAD = _this.name == 'HEAD';
        _this.isRemoteHEAD = _this.name.includes('/HEAD');
        _this.isLocalBranch = _this.name.indexOf('refs/heads/') == 0;
        _this.isRemoteBranch = isRemoteBranchOrHEAD && !_this.isRemoteHEAD;
        _this.isStash = _this.name.indexOf('refs/stash') == 0;
        _this.isHEAD = _this.isLocalHEAD || _this.isRemoteHEAD;
        _this.isBranch = _this.isLocalBranch || _this.isRemoteBranch;
        _this.isRemote = isRemoteBranchOrHEAD || _this.isRemoteTag;
        _this.isLocal = _this.isLocalBranch || _this.isLocalTag;
        if (_this.isLocalBranch) {
            _this.localRefName = _this.name.slice('refs/heads/'.length);
            _this.refName = _this.localRefName;
        }
        if (_this.isRemoteBranch) {
            _this.localRefName = _this.name.slice('refs/remotes/'.length);
        }
        if (_this.isLocalTag) {
            _this.localRefName = _this.name.slice('tag: refs/tags/'.length);
            _this.refName = _this.localRefName;
        }
        if (_this.isRemoteTag) {
            _this.localRefName = _this.name.slice('remote-tag: '.length);
        }
        var splitedName = _this.localRefName.split('/');
        if (_this.isRemote) {
            // get rid of the origin/ part of origin/branchname
            _this.remote = splitedName[0];
            _this.refName = splitedName.slice(1).join('/');
        }
        _this.show = true;
        _this.server = _this.graph.server;
        _this.isDragging = ko.observable(false);
        _this.current = ko.computed(function () { return _this.isLocalBranch && _this.graph.checkedOutBranch() == _this.refName; });
        _this.color = _this._colorFromHashOfString(_this.name);
        _this.node.subscribe(function (oldNode) {
            if (oldNode)
                oldNode.removeRef(_this);
        }, null, 'beforeChange');
        _this.node.subscribe(function (newNode) {
            if (newNode)
                newNode.pushRef(_this);
        });
        // This optimization is for autocomplete display
        _this.value = splitedName[splitedName.length - 1];
        _this.label = _this.localRefName;
        _this.displayHtml = function (largeCurrent) {
            var size = largeCurrent && _this.current() ? 26 : 18;
            var prefix = '';
            if (_this.isRemote) {
                prefix = "<span>".concat(octicons.globe.toSVG({ height: size }), "</span> ");
            }
            if (_this.isBranch) {
                prefix += "<span>".concat(octicons['git-branch'].toSVG({ height: size }), "</span> ");
            }
            else if (_this.isTag) {
                prefix += "<span>".concat(octicons.tag.toSVG({ height: size }), "</span> ");
            }
            return prefix + _this.localRefName;
        };
        return _this;
    }
    RefViewModel.prototype._colorFromHashOfString = function (string) {
        return "#".concat(md5(string).toString().slice(0, 6));
    };
    RefViewModel.prototype.dragStart = function () {
        this.graph.currentActionContext(this);
        this.isDragging(true);
        if (document.activeElement)
            document.activeElement.blur();
    };
    RefViewModel.prototype.dragEnd = function () {
        this.graph.currentActionContext(null);
        this.isDragging(false);
    };
    RefViewModel.prototype.moveTo = function (target, rewindWarnOverride) {
        var _this = this;
        var promise;
        if (this.isLocal) {
            var toNode = this.graph.nodesById[target];
            var args_1 = {
                path: this.graph.repoPath(),
                name: this.refName,
                sha1: target,
                force: true,
                to: target,
                mode: 'hard'
            };
            var operation_1;
            if (this.current()) {
                operation_1 = '/reset';
            }
            else if (this.isTag) {
                operation_1 = '/tags';
            }
            else {
                operation_1 = '/branches';
            }
            if (!rewindWarnOverride && this.node().date > toNode.date) {
                promise = new Promise(function (resolve, reject) {
                    components.showModal('yesnomodal', {
                        title: 'Are you sure?',
                        details: 'This operation potentially going back in history.',
                        closeFunc: function (isYes) {
                            if (isYes) {
                                return _this.server.postPromise(operation_1, args_1).then(resolve).catch(reject);
                            }
                        }
                    });
                });
            }
            else {
                promise = this.server.postPromise(operation_1, args_1);
            }
        }
        else {
            var pushReq_1 = {
                path: this.graph.repoPath(),
                remote: this.remote,
                refSpec: target,
                remoteBranch: this.refName
            };
            promise = this.server.postPromise('/push', pushReq_1).catch(function (err) {
                if (err.errorCode === 'non-fast-forward') {
                    return new Promise(function (resolve, reject) {
                        components.showModal('yesnomodal', {
                            title: 'Force push?',
                            details: "The remote branch can't be fast-forwarded.",
                            closeFunc: function (isYes) {
                                if (!isYes)
                                    return resolve(false);
                                pushReq_1.force = true;
                                _this.server.postPromise('/push', pushReq_1).then(resolve).catch(reject);
                            }
                        });
                    });
                }
                else {
                    _this.server.unhandledRejection(err);
                }
            });
        }
        return promise
            .then(function (res) {
            if (!res)
                return;
            var targetNode = _this.graph.getNode(target);
            if (_this.graph.checkedOutBranch() == _this.refName) {
                _this.graph.HEADref().node(targetNode);
            }
            _this.node(targetNode);
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    RefViewModel.prototype.remove = function (isClientOnly) {
        var _this = this;
        var url = this.isTag ? '/tags' : '/branches';
        if (this.isRemote)
            url = "/remote".concat(url);
        return (isClientOnly
            ? Promise.resolve()
            : this.server.delPromise(url, {
                path: this.graph.repoPath(),
                remote: this.isRemote ? this.remote : null,
                name: this.refName
            }))
            .then(function () {
            if (_this.node())
                _this.node().removeRef(_this);
            _this.graph.refs.remove(_this);
            delete _this.graph.refsByRefName[_this.name];
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); })
            .finally(function () {
            if (!isClientOnly) {
                if (url == '/remote/tags') {
                    programEvents.dispatch({ event: 'request-fetch-tags' });
                }
                else {
                    programEvents.dispatch({ event: 'branch-updated' });
                }
            }
        });
    };
    RefViewModel.prototype.getLocalRef = function () {
        return this.graph.getRef(this.getLocalRefFullName(), false);
    };
    RefViewModel.prototype.getLocalRefFullName = function () {
        if (this.isRemoteBranch)
            return "refs/heads/".concat(this.refName);
        if (this.isRemoteTag)
            return "tag: ".concat(this.refName);
        return null;
    };
    RefViewModel.prototype.getRemoteRef = function (remote) {
        return this.graph.getRef(this.getRemoteRefFullName(remote), false);
    };
    RefViewModel.prototype.getRemoteRefFullName = function (remote) {
        if (this.isLocalBranch)
            return "refs/remotes/".concat(remote, "/").concat(this.refName);
        if (this.isLocalTag)
            return "remote-tag: ".concat(remote, "/").concat(this.refName);
        return null;
    };
    RefViewModel.prototype.canBePushed = function (remote) {
        if (!this.isLocal)
            return false;
        if (!remote)
            return false;
        var remoteRef = this.getRemoteRef(remote);
        if (!remoteRef)
            return true;
        return this.node() != remoteRef.node();
    };
    RefViewModel.prototype.createRemoteRef = function () {
        var _this = this;
        return this.server
            .postPromise('/push', {
            path: this.graph.repoPath(),
            remote: this.graph.currentRemote(),
            refSpec: this.refName,
            remoteBranch: this.refName
        })
            .catch(function (e) { return _this.server.unhandledRejection(e); });
    };
    RefViewModel.prototype.checkout = function () {
        var _this = this;
        var isRemote = this.isRemoteBranch;
        var isLocalCurrent = this.getLocalRef() && this.getLocalRef().current();
        return Promise.resolve()
            .then(function () {
            if (isRemote && !isLocalCurrent) {
                return _this.server.postPromise('/branches', {
                    path: _this.graph.repoPath(),
                    name: _this.refName,
                    sha1: _this.name,
                    force: true
                });
            }
        })
            .then(function () {
            return _this.server.postPromise('/checkout', { path: _this.graph.repoPath(), name: _this.refName });
        })
            .then(function () {
            if (isRemote && isLocalCurrent) {
                return _this.server.postPromise('/reset', {
                    path: _this.graph.repoPath(),
                    to: _this.name,
                    mode: 'hard'
                });
            }
        })
            .then(function () {
            _this.graph.HEADref().node(_this.node());
        })
            .catch(function (err) {
            if (err.errorCode != 'merge-failed') {
                _this.server.unhandledRejection(err);
            }
            else {
                ungit.logger.warn('checkout failed', err);
            }
        });
    };
    return RefViewModel;
}(Selectable));
module.exports = RefViewModel;

},{"./selectable":9,"blueimp-md5":undefined,"knockout":undefined,"octicons":undefined,"ungit-components":undefined,"ungit-program-events":undefined}],7:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ko = require('knockout');
var _ = require('lodash');
var moment = require('moment');
var octicons = require('octicons');
var components = require('ungit-components');
var GitNodeViewModel = require('./git-node');
var GitRefViewModel = require('./git-ref');
var EdgeViewModel = require('./edge');
var ComponentRoot = require('../ComponentRoot').ComponentRoot;
var numberOfNodesPerLoad = ungit.config.numberOfNodesPerLoad;
components.register('graph', function (args) { return new GraphViewModel(args.server, args.repoPath); });
var GraphViewModel = /** @class */ (function (_super) {
    __extends(GraphViewModel, _super);
    function GraphViewModel(server, repoPath) {
        var _this = _super.call(this) || this;
        _this._isLoadNodesFromApiRunning = false;
        _this.updateBranches = _.debounce(_this._updateBranches, 250, _this.defaultDebounceOption);
        _this.loadNodesFromApi = _.debounce(_this._loadNodesFromApi, 250, _this.defaultDebounceOption);
        _this._markIdeologicalStamp = 0;
        _this.repoPath = repoPath;
        _this.limit = ko.observable(numberOfNodesPerLoad);
        _this.skip = ko.observable(0);
        _this.server = server;
        _this.currentRemote = ko.observable();
        _this.nodes = ko.observableArray();
        _this.edges = ko.observableArray();
        _this.refs = ko.observableArray();
        _this.nodesById = {};
        _this.edgesById = {};
        _this.refsByRefName = {};
        _this.checkedOutBranch = ko.observable();
        _this.checkedOutRef = ko.computed(function () {
            return _this.checkedOutBranch() ? _this.getRef("refs/heads/".concat(_this.checkedOutBranch())) : null;
        });
        _this.HEADref = ko.observable();
        _this.HEAD = ko.computed(function () { return (_this.HEADref() ? _this.HEADref().node() : undefined); });
        _this.commitNodeColor = ko.computed(function () { return (_this.HEAD() ? _this.HEAD().color() : '#4A4A4A'); });
        _this.commitNodeEdge = ko.computed(function () {
            if (!_this.HEAD() || !_this.HEAD().cx() || !_this.HEAD().cy())
                return;
            return "M 610 68 L ".concat(_this.HEAD().cx(), " ").concat(_this.HEAD().cy());
        });
        _this.currentActionContext = ko.observable();
        _this.scrolledToEnd = _.debounce(function () {
            _this.limit(numberOfNodesPerLoad + _this.limit());
            _this.loadNodesFromApi();
        }, 500, true);
        _this.loadAhead = _.debounce(function () {
            if (_this.skip() <= 0)
                return;
            _this.skip(Math.max(_this.skip() - numberOfNodesPerLoad, 0));
            _this.loadNodesFromApi();
        }, 500, true);
        _this.commitOpacity = ko.observable(1.0);
        _this.heighstBranchOrder = 0;
        _this.hoverGraphActionGraphic = ko.observable();
        _this.hoverGraphActionGraphic.subscribe(function (value) {
            if (value && value.destroy)
                value.destroy();
        }, null, 'beforeChange');
        _this.hoverGraphAction = ko.observable();
        _this.hoverGraphAction.subscribe(function (value) {
            if (value && value.createHoverGraphic) {
                _this.hoverGraphActionGraphic(value.createHoverGraphic());
            }
            else {
                _this.hoverGraphActionGraphic(null);
            }
        });
        _this.loadNodesFromApi();
        _this.updateBranches();
        _this.graphWidth = ko.observable();
        _this.graphHeight = ko.observable(800);
        _this.searchIcon = octicons.search.toSVG({ height: 18 });
        _this.plusIcon = octicons.plus.toSVG({ height: 18 });
        return _this;
    }
    GraphViewModel.prototype.updateNode = function (parentElement) {
        ko.renderTemplate('graph', this, {}, parentElement);
    };
    GraphViewModel.prototype.getNode = function (sha1, logEntry) {
        var nodeViewModel = this.nodesById[sha1];
        if (!nodeViewModel)
            nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
        if (logEntry)
            nodeViewModel.setData(logEntry);
        return nodeViewModel;
    };
    GraphViewModel.prototype.getRef = function (ref, constructIfUnavailable) {
        if (constructIfUnavailable === undefined)
            constructIfUnavailable = true;
        var refViewModel = this.refsByRefName[ref];
        if (!refViewModel && constructIfUnavailable) {
            refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
            this.refs.push(refViewModel);
            if (refViewModel.name === 'HEAD') {
                this.HEADref(refViewModel);
            }
        }
        return refViewModel;
    };
    GraphViewModel.prototype._loadNodesFromApi = function () {
        return __awaiter(this, void 0, void 0, function () {
            var nodeSize, edges, log, nodes, e_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._isLoadNodesFromApiRunning = true;
                        ungit.logger.debug('graph.loadNodesFromApi() triggered');
                        nodeSize = this.nodes().length;
                        edges = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.server.getPromise('/gitlog', {
                                path: this.repoPath(),
                                limit: this.limit(),
                                skip: this.skip()
                            })];
                    case 2:
                        log = _a.sent();
                        if (this.isSamePayload(log)) {
                            return [2 /*return*/];
                        }
                        nodes = this.computeNode((log.nodes || []).map(function (logEntry) {
                            return _this.getNode(logEntry.sha1, logEntry); // convert to node object
                        }));
                        // create edges
                        nodes.forEach(function (node) {
                            node.parents().forEach(function (parentSha1) {
                                edges.push(_this.getEdge(node.sha1, parentSha1));
                            });
                            node.render();
                        });
                        this.edges(edges);
                        this.nodes(nodes);
                        if (nodes.length > 0) {
                            this.graphHeight(nodes[nodes.length - 1].cy() + 80);
                        }
                        this.graphWidth(1000 + this.heighstBranchOrder * 90);
                        return [3 /*break*/, 5];
                    case 3:
                        e_1 = _a.sent();
                        this.server.unhandledRejection(e_1);
                        return [3 /*break*/, 5];
                    case 4:
                        if (window.innerHeight - this.graphHeight() > 0 && nodeSize != this.nodes().length) {
                            this.scrolledToEnd();
                        }
                        this._isLoadNodesFromApiRunning = false;
                        ungit.logger.debug('graph.loadNodesFromApi() finished');
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    GraphViewModel.prototype.traverseNodeLeftParents = function (node, callback) {
        callback(node);
        var parent = this.nodesById[node.parents()[0]];
        if (parent) {
            this.traverseNodeLeftParents(parent, callback);
        }
    };
    GraphViewModel.prototype.computeNode = function (nodes) {
        this.markNodesIdeologicalBranches(this.refs());
        var updateTimeStamp = moment().valueOf();
        if (this.HEAD()) {
            this.traverseNodeLeftParents(this.HEAD(), function (node) {
                node.ancestorOfHEADTimeStamp = updateTimeStamp;
            });
        }
        // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
        nodes = nodes.filter(function (node) {
            return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) ||
                node.ancestorOfHEADTimeStamp == updateTimeStamp;
        });
        var branchSlotCounter = this.HEAD() ? 1 : 0;
        // Then iterate from the bottom to fix the orders of the branches
        for (var i = nodes.length - 1; i >= 0; i--) {
            var node = nodes[i];
            if (node.ancestorOfHEADTimeStamp == updateTimeStamp)
                continue;
            var ideologicalBranch = node.ideologicalBranch();
            // First occurrence of the branch, find an empty slot for the branch
            if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
                ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
                ideologicalBranch.branchOrder = branchSlotCounter++;
            }
            node.branchOrder(ideologicalBranch.branchOrder);
        }
        this.heighstBranchOrder = branchSlotCounter - 1;
        var prevNode;
        nodes.forEach(function (node) {
            node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
            if (node.ancestorOfHEAD())
                node.branchOrder(0);
            node.aboveNode = prevNode;
            if (prevNode)
                prevNode.belowNode = node;
            prevNode = node;
        });
        return nodes;
    };
    GraphViewModel.prototype.getEdge = function (nodeAsha1, nodeBsha1) {
        var id = "".concat(nodeAsha1, "-").concat(nodeBsha1);
        var edge = this.edgesById[id];
        if (!edge) {
            edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
        }
        return edge;
    };
    GraphViewModel.prototype.markNodesIdeologicalBranches = function (refs) {
        var _this = this;
        refs = refs.filter(function (r) { return !!r.node(); });
        refs = refs.sort(function (a, b) {
            if (a.isLocal && !b.isLocal)
                return -1;
            if (b.isLocal && !a.isLocal)
                return 1;
            if (a.isBranch && !b.isBranch)
                return -1;
            if (b.isBranch && !a.isBranch)
                return 1;
            if (a.isHEAD && !b.isHEAD)
                return 1;
            if (!a.isHEAD && b.isHEAD)
                return -1;
            if (a.isStash && !b.isStash)
                return 1;
            if (b.isStash && !a.isStash)
                return -1;
            if (a.node() && a.node().date && b.node() && b.node().date)
                return a.node().date - b.node().date;
            return a.refName < b.refName ? -1 : 1;
        });
        var stamp = this._markIdeologicalStamp++;
        refs.forEach(function (ref) {
            _this.traverseNodeParents(ref.node(), function (node) {
                if (node.stamp == stamp)
                    return false;
                node.stamp = stamp;
                node.ideologicalBranch(ref);
                return true;
            });
        });
    };
    GraphViewModel.prototype.traverseNodeParents = function (node, callback) {
        if (!callback(node))
            return false;
        for (var i = 0; i < node.parents().length; i++) {
            // if parent, travers parent
            var parent_1 = this.nodesById[node.parents()[i]];
            if (parent_1) {
                this.traverseNodeParents(parent_1, callback);
            }
        }
    };
    GraphViewModel.prototype.handleBubbledClick = function (elem, event) {
        // If the clicked element is bound to the current action context,
        // then let's not deselect it.
        if (ko.dataFor(event.target) === this.currentActionContext())
            return;
        if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
            this.currentActionContext().toggleSelected();
        }
        else {
            this.currentActionContext(null);
        }
        // If the click was on an input element, then let's allow the default action to proceed.
        // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
        // will trigger a click event on the submit input of the form, which will end up here,
        // and if we don't return true, then the submit event is never fired, breaking stuff.
        if (event.target.nodeName === 'INPUT')
            return true;
    };
    GraphViewModel.prototype.onProgramEvent = function (event) {
        if (event.event == 'git-directory-changed' || event.event === 'working-tree-changed') {
            this.loadNodesFromApi();
            this.updateBranches();
        }
        else if (event.event == 'request-app-content-refresh') {
            this.loadNodesFromApi();
        }
        else if (event.event == 'remote-tags-update') {
            this.setRemoteTags(event.tags);
        }
        else if (event.event == 'current-remote-changed') {
            this.currentRemote(event.newRemote);
        }
        else if (event.event == 'graph-render') {
            this.nodes().forEach(function (node) {
                node.render();
            });
        }
    };
    GraphViewModel.prototype.updateAnimationFrame = function (deltaT) {
        this.nodes().forEach(function (node) {
            node.updateAnimationFrame(deltaT);
        });
    };
    GraphViewModel.prototype._updateBranches = function () {
        return __awaiter(this, void 0, void 0, function () {
            var checkout;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.server.getPromise('/checkout', { path: this.repoPath() })];
                    case 1:
                        checkout = _a.sent();
                        try {
                            ungit.logger.debug('setting checkedOutBranch', checkout);
                            this.checkedOutBranch(checkout);
                        }
                        catch (err) {
                            if (err.errorCode != 'not-a-repository') {
                                this.server.unhandledRejection(err);
                            }
                            else {
                                ungit.logger.warn('updateBranches failed', err);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphViewModel.prototype.setRemoteTags = function (remoteTags) {
        var _this = this;
        var version = Date.now();
        var sha1Map = {}; // map holding true sha1 per tags
        remoteTags.forEach(function (tag) {
            if (tag.name.includes('^{}')) {
                // This tag is a dereference tag, use this sha1.
                var tagRef = tag.name.slice(0, tag.name.length - '^{}'.length);
                sha1Map[tagRef] = tag.sha1;
            }
            else if (!sha1Map[tag.name]) {
                // If sha1 wasn't previously set, use this sha1
                sha1Map[tag.name] = tag.sha1;
            }
        });
        remoteTags.forEach(function (ref) {
            if (!ref.name.includes('^{}')) {
                var name_1 = "remote-tag: ".concat(ref.remote, "/").concat(ref.name.split('/')[2]);
                _this.getRef(name_1).node(_this.getNode(sha1Map[ref.name]));
                _this.getRef(name_1).version = version;
            }
        });
        this.refs().forEach(function (ref) {
            // tag is removed from another source
            if (ref.isRemoteTag && (!ref.version || ref.version < version)) {
                ref.remove(true);
            }
        });
    };
    GraphViewModel.prototype.checkHeadMove = function (toNode) {
        if (this.HEAD() === toNode) {
            this.HEADref().node(toNode);
        }
    };
    return GraphViewModel;
}(ComponentRoot));

},{"../ComponentRoot":1,"./edge":3,"./git-node":5,"./git-ref":6,"knockout":undefined,"lodash":undefined,"moment":undefined,"octicons":undefined,"ungit-components":undefined}],8:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var getEdgeModelWithD = function (d, stroke, strokeWidth, strokeDasharray, markerEnd) { return ({
    d: d,
    stroke: stroke ? stroke : '#4A4A4A',
    strokeWidth: strokeWidth ? strokeWidth : '8',
    strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
    markerEnd: markerEnd ? markerEnd : ''
}); };
var getEdgeModel = function (scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) {
    return getEdgeModelWithD("M ".concat(scx, " ").concat(scy, " L ").concat(tcx, " ").concat(tcy), stroke, strokeWidth, strokeDasharray, markerEnd);
};
var getNodeModel = function (cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) { return ({
    cx: cx,
    cy: cy,
    r: r,
    fill: fill,
    stroke: stroke ? stroke : '#41DE3C',
    strokeWidth: strokeWidth ? strokeWidth : '8',
    strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5'
}); };
var HoverViewModel = /** @class */ (function () {
    function HoverViewModel() {
        this.bgEdges = [];
        this.nodes = [];
        this.fgEdges = [];
    }
    return HoverViewModel;
}());
var MergeViewModel = /** @class */ (function (_super) {
    __extends(MergeViewModel, _super);
    function MergeViewModel(graph, headNode, node) {
        var _this = _super.call(this) || this;
        _this.graph = graph;
        _this.bgEdges = [
            getEdgeModel(headNode.cx(), headNode.cy() - 110, headNode.cx(), headNode.cy()),
            getEdgeModel(headNode.cx(), headNode.cy() - 110, node.cx(), node.cy()),
        ];
        _this.nodes = [
            getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5'),
        ];
        graph.commitOpacity(0.1);
        return _this;
    }
    MergeViewModel.prototype.destroy = function () {
        this.graph.commitOpacity(1.0);
    };
    return MergeViewModel;
}(HoverViewModel));
exports.MergeViewModel = MergeViewModel;
var RebaseViewModel = /** @class */ (function (_super) {
    __extends(RebaseViewModel, _super);
    function RebaseViewModel(onto, nodesThatWillMove) {
        var _this = _super.call(this) || this;
        nodesThatWillMove = nodesThatWillMove.slice(0, -1);
        if (nodesThatWillMove.length == 0)
            return _this;
        _this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
        nodesThatWillMove.forEach(function (node, i) {
            var cy = onto.cy() + -90 * (i + 1);
            _this.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
            if (i + 1 < nodesThatWillMove.length) {
                _this.bgEdges.push(getEdgeModel(onto.cx(), cy - 25, onto.cx(), cy - 65));
            }
        });
        return _this;
    }
    return RebaseViewModel;
}(HoverViewModel));
exports.RebaseViewModel = RebaseViewModel;
var ResetViewModel = /** @class */ (function (_super) {
    __extends(ResetViewModel, _super);
    function ResetViewModel(nodes) {
        var _this = _super.call(this) || this;
        nodes.forEach(function (node) {
            _this.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
            _this.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
        });
        return _this;
    }
    return ResetViewModel;
}(HoverViewModel));
exports.ResetViewModel = ResetViewModel;
var PushViewModel = /** @class */ (function (_super) {
    __extends(PushViewModel, _super);
    function PushViewModel(fromNode, toNode) {
        var _this = _super.call(this) || this;
        _this.fgEdges = [
            getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), toNode.cy() + 40, 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)'),
        ];
        return _this;
    }
    return PushViewModel;
}(HoverViewModel));
exports.PushViewModel = PushViewModel;
var SquashViewModel = /** @class */ (function (_super) {
    __extends(SquashViewModel, _super);
    function SquashViewModel(from, onto) {
        var _this = _super.call(this) || this;
        var path = from.getPathToCommonAncestor(onto);
        if (path.length == 0) {
            return _this;
        }
        else if (path.length == 1) {
            path = onto.getPathToCommonAncestor(from);
        }
        else {
            _this.nodes.push(getNodeModel(onto.cx(), onto.cy() - 120, 28, 'transparent'));
        }
        path.slice(0, -1).forEach(function (node) {
            _this.nodes.push(getNodeModel(node.cx(), node.cy(), node.r() + 2, 'rgba(100, 60, 222, 0.8)'));
        });
        return _this;
    }
    return SquashViewModel;
}(HoverViewModel));
exports.SquashViewModel = SquashViewModel;

},{}],9:[function(require,module,exports){
var ko = require('knockout');
var Selectable = /** @class */ (function () {
    function Selectable(graph) {
        this.selected = ko.computed({
            read: function () {
                return graph.currentActionContext() == this;
            },
            write: function (val) {
                // val is this if we're called from a click ko binding
                if (val === this || val === true) {
                    graph.currentActionContext(this);
                }
                else if (graph.currentActionContext() == this) {
                    graph.currentActionContext(null);
                }
            },
            owner: this
        });
    }
    return Selectable;
}());
module.exports = Selectable;

},{"knockout":undefined}]},{},[7])
//# sourceMappingURL=graph.bundle.js.map
